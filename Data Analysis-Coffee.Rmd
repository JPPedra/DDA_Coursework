---
title: "CS5811-Data Distributed Analysis-Data Analysis on Arabica Coffee Beans"
author: "Hawra Nawrozzadeh, Joao Pedro Azevedo, and Roberta Sammarco"
date: "10/02/2022"
output: html_document
version: 1.0
editor_options: 
  chunk_output_type: inline
---

# 1. Introduction

- The Dataset is on Coffee Arabica Beans 
- The metadata is as followed:

Quality Measures Metadata    
 - Aroma                       
 - Flavor                       
 - Aftertaste                   
 - Acidity                     
 - Body                       
 - Balance              
 - Uniformity              
 - Cup Cleanliness           
 - Sweetness            
 - Moisture                
 - Defects          

Farm Metadata     
- Owner           
- Country of Origin    
- Farm Name            
- Lot Number        
- Mill              
- Company            
- Altitude          
- Region            

Bean Metadata     
- Processing Method 
- Color             
- Species (arabica)

- Research Question: 
"Given the attributes of the Arabica Coffee beans, can we predict the overall coffee quality score?"

# 2. Loading the Libraries

```{r}
# For data cleaning and preparation
library(dplyr)
library(tidyverse)
library(validate)
library(plyr)
# For Data visualisation
library(ggplot2)
library(magrittr)
```

# 3. Data Cleaning and Preparation

## 3.1 Loading the data 

```{r}
coffee <- read.csv("ArabicaCoffeeBeans.csv")
```


## 3.2 Data Qaulity Check, Data Cleaning and Preparation 

Let's look into the structure of the data set
```{r}
str(coffee)
summary(coffee)
```

-From the 'summary()' and 'str()' function, it seems R has processed the dataset with  35 attributes categorical variables and the rest of the 9 attributes to be numerical continuous.
- However, this seems to be incorrect format because the in correct datatype.
  - For example, variables such as 'Acidity' and 'Aftertaste' contains numerical observations however, has been processed as character data types.
- Additionally, we can already identify errors such as missing data and possible outliers (from looking at the ranges from the summary function)

- Lets further look into the different levels by creating an object that converts the strings into a factor.
  - using 'stringAsFactor = T'
- By doing this, we can also see other details that we will help us to decide which attributes are redundant or irrelavent for our research question. 
```{r}
coffee_fac_lev <- read.csv("ArabicaCoffeeBeans.csv", stringsAsFactors = T)
str(coffee_fac_lev)
summary(coffee_fac_lev)
```
- There is alot of errors and redudant information
- can see the amount of missings informations, etc. 
- This is also evident in the validate package below:

validate
Through the validate Package we check if in the data set the variables are accurate and if there are any missing values.
The coffee.rules are useful to check the quality of data. We have created the data rules based on the 'structure' and on the 'summary' functions.
```{r}

coffee.rules <- validator(#check if data type is correct
check.NBags.DataType = is.numeric(Number.of.Bags),
check.Aroma.DataType = is.numeric(Aroma),
check.Flavor.DataType = is.numeric(Flavor),
check.Taste.DataType = is.numeric(Aftertaste),
check.Acidity.DataType = is.numeric(Acidity),
check.Body.DataType = is.numeric(Body),
check.Balance.DataType = is.numeric(Balance),
check.Uniformity.DataType = is.numeric(Uniformity),
check.CleanCup.DataType = is.numeric(Clean.Cup),
check.TotCupPoints.DataType = is.numeric(Total.Cups.Points),
check.CupperPoints.DataType = is.numeric(Cupper.Points),
check.Moisture.DataType = is.numeric(Moisture),
check.CategoryOneDef.DataType = is.numeric(Category.One.Defects),
check.ProcessMeth.DataType = is.factor(Processing.Method),
check.Quakers.DataType = is.factor(Quakers),
CheckWeight = is.element(Bag.Weight, ("kg")), #check unit of measure

#check spelling
CheckProcessMeth = is.element(Processing.Method,
c("Washed / Wet", "Natural/ Dry", "Pulped natural / honey", "Semi-washed / Semi-pulped", "Other")),
CheckColor = is.element(Color,
c("Green", "None" , "Bluish-Green", "Blue-Green")), #check spelling
CheckNoBags = Number.of.Bags>0, #check no negatives
CheckFlavor = Flavor>0, #check no negatives
CheckAftertaste = Aftertaste>0, #check no negatives
CheckAcidity = Acidity>0, #check no negatives
CheckBody = Body>0, #check no negatives
CheckBalance = Balance>0, #check no negatives
CheckMoisture = Moisture>0, #check no negatives
CheckQuakers = Quakers>=0, #check no negatives
CheckMaxLowAltitute = altitude_low_meters>=1,
CheckMinAltitute = altitude_low_meters <= 190164,
CheckMaxHighAltitute = altitude_high_meters>=1,
CheckMinHighAltitute = altitude_high_meters <= 190164,
CheckMaxMeanAltitute = altitude_mean_meters>=1,
CheckMinMeanAltitute = altitude_mean_meters <= 190164
)
```

The 'quality.check' function used below will check if all items in the coffee.rules created, can pass or fail. Moreover, we can check how many missing values there are for each variable. If a rule do not pass, the error column will display 'True', otherwise it display 'False'

```{r}
quality.check <- confront(coffee_new, coffee.rules) # To check the coffee quality rules
summary (qual.check)
```
Through the plot we can visualize better the errors found in the quality check.
```{r}
plot (quality.check)#to visualize the quality check of the coffee through a plot
```

## 3.3 Subset the dataset

- As a results, in order to answer our research, we will subset the dataset to contain the following variables: 
  - Country.of.Origin       
  - Number.of.Bags               
  - Bag.Weight                                   
  - Processing.Method                             
  - Aroma                                         
  - Flavor                                        
  - Aftertaste                                    
  - Acidity                                       
  - Body                                          
  - Balance                                       
  - Uniformity                                    
  - Clean.Cup                                     
  - Sweetness                                     
  - Cupper.Points                                 
  - Total.Cup.Points                              
  - Moisture                                      
  - Category.One.Defects                          
  - Quakers                                       
  - Category.Two.Defects  

- Will now subset the dataset
```{r} 
# Lets get the column names
colnames(coffee)

# Are subsetting and removing the following columns mainly because all these variables had missing variables and would not help in answering our research question
coffee_new <- coffee %>%
  select(-c( ## removing data regarding the Farm 
            "Owner", "Farm.Name", "Lot.Number", "Mill", "ICO.Number",
            "Company","Region","Producer","In.Country.Partner","Harvest.Year","Owner.1","Variety", "Expiration",
            "Certification.Body","Certification.Address","Certification.Contact","unit_of_measurement",
            ## removing data regard the bean
            "Color", "Species", "Altitude", "altitude_low_meters", "altitude_high_meters", "altitude_mean_meters","Grading.Date"
            )
         )
# Let check the new changes
colnames(coffee_new)
str(coffee_new)
summary(coffee_new)
```

## 3.4 Data Type Conversions and Dealing with Missing Data

- Let's see if there are still any missing rows and if so, let remove them
```{r}
summary(coffee_new)
colSums(is.na(coffee_new))
colSums(coffee_new == "")

#https://stackoverflow.com/questions/42721788/filter-empty-rows-from-a-dataframe-with-r
coffee_new_1 <- coffee_new[Reduce(`&`, lapply(coffee_new, 
                                              function(x) !(x==""))),]

colSums(is.na(coffee_new_1))
colSums(coffee_new_1 == "")
```

# Variables:

Perform data type conversion 
- character to factors
- character that hold numbers to double numerical 
- excluding bag weight as the conversion would not work -> both string and "number" and the units are not the same

```{r}
#converting data type as factor
coffee_new_1$Processing.Method<-as.factor(coffee_new_1$Processing.Method)

#converting data type as double numerical
coffee_new_1$Number.of.Bags <- as.double(coffee_new_1$Number.of.Bags)
coffee_new_1$Quakers<-as.factor(coffee_new_1$Quakers)

coffee_new_1$Aroma<-as.double(coffee_new_1$Aroma)
coffee_new_1$Flavor<-as.double(coffee_new_1$Flavor)
coffee_new_1$Aftertaste<-as.double(coffee_new_1$Aftertaste)
coffee_new_1$Acidity<-as.double(coffee_new_1$Acidity)
coffee_new_1$Body<-as.double(coffee_new_1$Body)
coffee_new_1$Balance<-as.double(coffee_new_1$Balance)
coffee_new_1$Uniformity<-as.double(coffee_new_1$Uniformity)
coffee_new_1$Clean.Cup<-as.double(coffee_new_1$Clean.Cup)
coffee_new_1$Total.Cup.Points<-as.double(coffee_new_1$Total.Cup.Points)
coffee_new_1$Cupper.Points<-as.double(coffee_new_1$Cupper.Points)
coffee_new_1$Moisture<-as.double(coffee_new_1$Moisture)
coffee_new_1$Category.One.Defects<-as.double(coffee_new_1$Category.One.Defects) 
#checking the structure of the data set with new data types
str(coffee_new_1)
```

- Then apply NA imputation to all numerical variables
```{r}
# impute missing values by replacement with the mean value
  # using mutate_if function and if else condition to find any NAs in any numerical columns and replace it with their according median
coffee_new_1 <- coffee_new_1 %>% 
  mutate_if(is.numeric, function(x) ifelse(is.na(x), median(x, na.rm = T), x))
colSums(is.na(coffee_new_1))
```

-dealing with Bag Weight problem
  - all string 
  - Majority is kg put there are some in lbs
  - Created a function to fix this so that all the values are converted to numeric and all have the same unit
  
```{r}
# 1) replace NA with fake number as the function below is sensitive to NAs 
coffee_new$Bag.Weight <- coffee_new$Bag.Weight %>% 
  replace_na("99999 kg")

# 2) Check that NAs in Bag weight have been temporarily been replaced
colSums(is.na(coffee_new)) 

# 3) Will write and export this file in order to perform the function in PySpark (Hawra's HPCI Technique) 
write.csv(coffee_new, file = "Data/Arabica-coffee-half-modified.csv", row.names = FALSE)

# 4) Will now load the results from the function that was performed in Pyspark (Hawra's HPCI Technique)
coffee_new_1 <- read.csv("Data/ArabicaCoffeeBeansNew-UnitConversionWithString.csv")

# 4) Lets have a look at the `Bag.Weight`
table(coffee_new_1$Bag.Weight)
str(coffee_new)
```

```{r}
# have to change the fake number to NA before doing NA imputation to Bag Weight , will use the naniar function
table(coffee_new_1$Bag.Weight)
library(naniar)
#exp<- coffee_new_1
coffee_new_1 <- coffee_new_1 %>% 
  replace_with_na(replace = list(Bag.Weight = 99999))
table(coffee_new_1$Bag.Weight)
colSums(is.na(coffee_new_1))
```

```{r}
# Then perform NA imputation to Bag weight

median_Bag_weight <- median(coffee_new_1$Bag.Weight, na.rm = T)
coffee_new_1[is.na(coffee_new_1$Bag.Weight), 10.000] = median_Bag_weight

# Then drop any other NA from the character variables

coffee_new_1 <- na.omit(coffee_new_1)
```

## 3.5 Identify and Dealing with Outliers

This section investigates whether the current dataset has any outliers. 

The investigation plan starts by analysing the structure of the dataset and then by investigating the distribution of each variable to draw possible conclusions about the outliers.

In this section, any identified outliers were corrected, when possible.

```{r}
# function displays the structure of the current dataset and gives more information about each variable's datatype -
# to understand if all the variables were correctly converted 

str(coffee_new_1)
```

Having analysed the structure of the current dataset; investigate each variable separately, starting by Country.of.Origin.

# 1- Country.of.Origin 

```{r}
# function returns the frequency for this variable - makes it possible to identify any outliers by looking at extreme frequencies

table(coffee_new_1$Country.of.Origin)

#Code replaces the name of the variable by correct the value --) Cote d'Ivoire

coffee_new_1["Country.of.Origin"][coffee_new_1["Country.of.Origin"] == "Cote d?Ivoire"] = "Cote d'Ivoire"

#Code replaces the name of the variable by correct the value --) United Republic of Tanzania

coffee_new_1["Country.of.Origin"][coffee_new_1["Country.of.Origin"] == "Tanzania, United Republic Of"] = "United Republic of Tanzania"

#Code replaces the name of the variable by correct the value --) Hawaii

coffee_new_1["Country.of.Origin"][coffee_new_1["Country.of.Origin"] == "United States (Hawaii)"] = "Hawaii"

```

Table function shows that the variable country has one value for "Cote d?Ivoire". This country corresponds to Côte d'Ivoire and it might have been wrongly imputed. Moreover, the same happens with "Tanzania, United Republic Of" that should be United Republic of Tanzania instead, and with the country Hawaii.


# 2- Number.of.Bags 

```{r}
# the variable was not previously converted and it should be numeric type - function is used to convert the variable to the correct datatype.

coffee_new_1$Number.of.Bags <- as.numeric(coffee_new_1$Number.of.Bags)

# plot to investigate any outliers - displaying the distribution of the variable makes it possible to identfy any extreme variables that correspond to outliers.

ggplot(coffee_new_1) + aes(x = Number.of.Bags) + geom_histogram(bins = 30L, fill = "#0c4c8a") + theme_minimal()

# Use summary function to confirm any outliers - should be the maximum value for this variable 
summary(coffee_new_1$Number.of.Bags)
```

The histogram shows that the variable has one possible outlier -  there seems to be one observation higher than all other observations; corresponds to the maximum value of this variable. 

The summary function is then used to get the maximum value for this variable (as this value was previously identified as being an outlier)
The summary function output shows a Max of 1062 - according to the histogram ploted above, this makes sense to be the outlier.

Moreover, it is then necessary to identify the problem with 1062 number of bags, as it is a value out of the ordinary for this variable and is considered to be a possible outlier - boxplot function is used below to do so.

```{r}
# boxplot function to identify the possible outlier
bags_boxplot <- boxplot(coffee_new_1$Number.of.Bags, plot = F)

# minimum function will get this number as the minimum outlier possible
bags_threshold <- min(bags_boxplot$out)

bags_threshold # returns 1062, which is the outlier identified in the summary function
```

The boxplot and min functions return the value of 1062 as the possible outlier.

To understand if 1062 is an outlier and its context within the current dataset - subset function is used to understand which country has 1062 number of bags. By sub-setting the country which has 1062 number of bags, the output allows it to understand if it is the norm to have this many bags in a certain country.

```{r}
# function to identify which country has 1062 number of bags
subset(coffee_new_1, Number.of.Bags == 1062.0)

# function to understand if it is the norm for Brazil to have 1000 number of bags
subset(coffee_new_1, Country.of.Origin == "Brazil")
```

The first subset function shows that Brazil is the country with 1062 number of bags (possible outlier)
The country Brazil is not set to have 1000 number of bags as the norm. This means that 1062 number of bags is an outlier and needs further investigation.

However, for line 735, with 1062 number of bags, this variable has 6 quackers, which relates to the poor quality of this set of coffee beans. This explains why there are more number of bags - less quality coffee leads to the need to collect more beans, which leads to more number of bags.

Therefore, this coffee beans have less quality than others and that is why there are more number of bags for line 735 - which makes this instance not an outlier.


# 3 - Quakers - unripened coffee beans, often with a wrinkled surface, not darken well when roasted.

```{r}
# Function to get the frequency of the variable Quakers - showing 2 NAs for this variable
# The output shows if any frequency is out of the ordinary; which allows it to identify any possible outliers.

count(coffee_new_1, 'Quakers')

# this function replaces NA by 0
coffee_new_1[is.na(coffee_new_1$Quakers) , ] = 0

# NOTE based on the output:
# Quakers are not necessarily less than 3, go up and change the validate function. 

# plot the distribution of the variable Quakers to confirm the output of function count and check for outliers 
ggplot(coffee_new_1, aes(Quakers)) + geom_bar(fill = "#0099F8") + ggtitle("Quakers in the coffee quality")
```

The count function output shows that the variable Quakers ranges from level 0 to 11 - being 11 maximum level of coffee roastiness. 

The function does not identify any outliers within the Quakers variable - this variable needs further investigation; by looking at its distribution; the geom_bar plot makes that possible.

The plot shows no outliers as all the values range from 0 to 11 - with no extreme values. However, the plot shows an extremely high frequency for level 0 of Quakers - this does not correspond to outliers as level 0 represents missing information for this variable.

# 4 - Processing.Method

```{r}
# Function to get the frequency of this variable - it shows 2 missing values for this variable
# The output shows if any frequency is out of the ordinary; which allows it to identify any possible outliers.
count(coffee_new_1, 'Processing.Method')

# output shows NA, this function replaces NA by "Other"
coffee_new_1[is.na(coffee_new_1$Processing.Method) , ] <- "Other"

# plot the distribution of the variable Processing.Method to confirm the output of the function count and check for outliers 
ggplot(coffee_new_1, aes(Processing.Method)) + geom_bar(fill="steelblue") + coord_flip() 
```


The output shows no outliers for the Processing.Method variable - it also shows that both NA was correctly replaced by "Other".
It is showing that "Washed/Wet" is the most used processing method and that "Pulped natural" is the least used.

To conclude, both the count and ggplot functions show no outliers for the Processing.Method variable.


# 5 -  Total.Cup.Points - score coffee on a standardized scale, from 0 to 100.

This variable should range from 0 to 100 and, for a better quality coffee, it should have a value between 80 to 90 (Authentic Coffee Co., 2022).
This variable represents an overall quality score for coffee and is the target variable of the regression model. Meaning, it is an important variable to answer the research question identified previously in this project.

```{r}
# function displays the median value of Total.Cup.Points for each Country of origin
aggregate(coffee_new_1$Total.Cup.Points, list(coffee_new_1$Country.of.Origin), FUN=mean)

# function displays the distribution of the variable - to identify any possible outliers.
ggplot(coffee_new_1, aes(Total.Cup.Points)) + geom_histogram(binwidth = 4, color="black",fill="lightblue",linetype="dashed")
```

The output shows an average of Total.Cup.Points similar to all the countries in this dataset. This means that there are not potential outliers for the Total.Cup.Points variable - the values range between 0 and 100.

Moreover, the output shows that countries like Cote d'Ivoire, Haiti, India and Nicaragua have a poor Total.Cup.Points value, as it is less than 80.

Concluding, this list shows no outliers as all the values range from 0 to 100, for the Total.Cup.Points variable.


# 6 - Aroma, Flavor, Aftertaste, Acidity, Body, Balance, Uniformity, Clean.Cup, Sweetness

The coffee quality can be measured by professionals according to several factors such as: Acidity, Aroma, Flavor, Balance, Sweetness, among others. They also grade each one of these factors in order to get the final score, which indicates the quality of this coffee (Souza, 2022) - corresponding to the Total.Cup.Points.

Distribution of these variables is presented below.

```{r}
# the variable was not previously converted and it should be numeric type.
coffee_new_1$Sweetness <- as.numeric(coffee_new_1$Sweetness)

# the variable was not previously converted and it should be numeric type.
coffee_new_1$Cupper.Points <- as.numeric(coffee_new_1$Cupper.Points)

# boxplot all the numerical variables to investigate any possible outliers.

boxplot(coffee_new_1$Aroma,coffee_new_1$Flavor,coffee_new_1$Aftertaste,main = "Boxplot 1 for comparision of three numerical variables", names = c("Aroma", "Flavor", "Aftertaste"), col = c("orange","red"), border = "brown", horizontal = TRUE, notch = TRUE)

boxplot(coffee_new_1$Acidity,coffee_new_1$Body,coffee_new_1$Balance,main = "Boxplot 2 for comparision of three numerical variables", names = c("Acidity", "Body", "Balance"), col = c("blue","black"), border = "brown", horizontal = TRUE, notch = TRUE)

boxplot(coffee_new_1$Uniformity,coffee_new_1$Clean.Cup,coffee_new_1$Sweetness,main = "Boxplot 3 for comparision of three numerical variables", names = c("Uniformity", "Clean.Cup", "Sweetness"), col = c("red","yellow"), border = "brown", horizontal = TRUE, notch = TRUE)
```

The boxplot output above represented shows that there is one possible outlier for variables Aroma, Acidity and Clean.Cup.

To better understand this outliers, it is necessary to use the boxplot and minimum functions below presented.

```{r}
# AROMA VARIABLE
Aroma_boxplot <- boxplot(coffee_new_1$Aroma, plot = F)
Aroma_threshold <- min(Aroma_boxplot$out)
Aroma_threshold # value of the possible outlier for aroma is 5.08

# ACIDITY VARIABLE
Acidity_boxplot <- boxplot(coffee_new_1$Acidity, plot = F)
Acidity_threshold <- min(Acidity_boxplot$out)
Acidity_threshold # value of the possible outlier for aroma is 5.25

# BODY VARIABLE
Body_boxplot <- boxplot(coffee_new_1$Body, plot = F)
Body_threshold <- min(Body_boxplot$out)
Body_threshold # value of the possible outlier for aroma is 6.33

# Clean.Cup VARIABLE
Clean.Cup_boxplot <- boxplot(coffee_new_1$Clean.Cup, plot = F)
Clean.Cup_boxplot_threshold <- min(Clean.Cup_boxplot$out)
Clean.Cup_boxplot_threshold # value of the possible outlier for aroma is 6.33

# subset function to extract the possible outliers and understand why this variables are displaying certain values.
subset(coffee_new_1, Aroma == 5.08)
subset(coffee_new_1, Acidity == 5.25)
subset(coffee_new_1, Body == 6.33)
subset(coffee_new_1, Clean.Cup == 0)
```

The first one, happens when  Aroma = 5.08 and Acidity = 5.25. However, even thought these two variables are out of the mean values, they range between 0-10, which means that they should not be outliers.

Finally, the output also shows a value of 6.33 for Body when Acidity is 7.08 - even thought is a high value for body when compared with the rest of the variable but it is still within the correct range.
Meaning, the variables that make up the Total.Cup.Points variable do not present any outliers. 


# 7 - Cupper.Points and Clean.Cup

Furthermore, the variables: Cupper.Points (Any negative marks that appear in the Uniformity), Clean Cup and Sweetness categories are deducted as two points per cup, with the varible Clean.Cup - refers to a coffee free of taints and defects.

```{r}
par(mfrow=c(1,2))

# histogram shows the distribution of the two variables to identify possible outliers

hist(coffee_new_1$Cupper.Points, main="Histogram of coffee Cupper.Points",xlab="Coffee´s Cupper.Points", ylab="")
hist(coffee_new_1$Clean.Cup, main="Histogram of coffee Clean.Cup",xlab="Coffee´s Clean.Cup", ylab="")

# count function to confirm there are no outliers as represented in the ggplot output
count(coffee_new_1, 'Cupper.Points')
count(coffee_new_1, 'Clean.Cup')
```

The histogram output does not present any possible outlier for these two variables.
The count function was also used to confirm the histograms output - function allows it to investigate the frequency of each variable and look for one that is out of the ordinary. 

Furthermore, as the clean.cup variable corresponds to a coffee free of taints and defects, it makes sense to have 1057 count when clean cup is equal to 10. This means that 1057 coffee beans have no defects.


# 8 - Moisture

```{r}
# ggplot function to investigate any possible outliers.
ggplot(coffee_new_1, aes(Moisture)) + geom_boxplot()

# function to confirm the visual output
count(coffee_new_1, 'Moisture')
```

The ggplot output shows that this variable does present outliers. To confirm this output, count function is used to investigate this variables frequency.
Most coffee beans have a 0.1 level of moisture levels - counct function output shhows that the previous identified extreme values are not outliers.

# 8 - Category.One.Defects and Category.Two.Defects

According to Hetzel (2022), bean defects of Category One are rare, as are Quakers - imperfections in the coffee quality that affect its characteristics like Aroma, Acidity, etc.
Bean defects of Category Two are more common and the distribution appears to be approximately log-normal.

```{r}
count(coffee_new_1, 'Category.One.Defects')
count(coffee_new_1, 'Category.Two.Defects')


par(mfrow=c(1,2))

# histogram shows the distribution of the two variables to identify possible outliers

hist(coffee_new_1$Category.One.Defects, main="Histogram of coffee Category.One.Defects",xlab="Coffee´s Category.One.Defects", ylab="")

hist(coffee_new_1$Category.Two.Defects, main="Histogram of coffee Category.Two.Defects",xlab="Coffee´s Category.Two.Defects", ylab="")
```

The histograms do not display any outlier for the two variables.
The count function was also used to confirm the absence of outliers in these two variables.
Both outputs show a high frequency of values when the category defects is equal to 0. This makes sense as the variable represents the presence of defects in coffee beans - meaning, the beans have good quality across different countries.

Nevertheless, there are some extreme frequencies that correspond to higher values when compared to all the other ones.
Therefore, it is important to further investigate these variables.

To do so - plot the data with boxplot to investigate if the higher frequencies are outliers.

```{r}
ggplot(coffee_new_1, aes(Category.Two.Defects,Category.Two.Defects)) + geom_boxplot()
```

ggplot output shows many outliers for the Category.One.Defects and Category.Two.Defects variables - use boxplot and min functions to remove these outliers.

```{r}
# boxplot to identify all these outliers
category_boxplot <- boxplot(coffee_new_1$Category.Two.Defects, plot = F)

# minimum function will set one outlier as the first outlier, which means that all numbers above that one will be considered to be outliers
category_threshold <- min(category_boxplot$out)


# function to remove the previously identified outliers and store the clean variables into a new dataset
dataset_clean <- coffee_new_1[coffee_new_1$Category.Two.Defects< min(category_boxplot$out), ]
dataset_clean


par(mfrow=c(1,2))

# histogram shows the distribution of the two new variables with no outliers.

hist(dataset_clean$Category.One.Defects, main="Clean Histogram of coffee Category.One.Defects",xlab="Coffee´s Category.One.Defects", ylab="")

hist(dataset_clean$Category.Two.Defects, main="Clean Histogram of coffee Category.Two.Defects",xlab="Coffee´s Category.Two.Defects", ylab="")
```

## 3.6 summary of the data preparation and cleaning
- conclusion 
- validate afterwards

################ EDA ################
# 4. Exploratory Data Analysis
################ EDA ################

# Research question:

"Given the Quality measures of the Arabic Coffee beans, can we predict the overall coffee quality score?"

Machine Learning Method in which the Target Variable is Total.Cup.Points.

# EDA Plan:

It is crucial to look at the summary statistics when starting the exploratory data analysis of the data set. The summary function gives an idea of how normally distributed each variable is, when the median and mean values are similar. 

```{r}
summary(coffee_new_1)
```

The summary function output shows that variables like Aroma, Flavor, Acidity, Body, Balance, Sweetness, Clean.Cup, Total.Cup.Points have similar values for median and mean - it is possible to assume that these variables present a normal distribution. 

Nevertheless, the variables presented above need further visual investigation, to actually understand if they have symmetric distribution.


# 1 - Explore each variable individually to understand if they are normally distributed and can be used in a Machine Learning moodel - starting by the target variable Total.Cup.Points.

Analysis of green coffee includes a detailed report of the green coffee grading, cupping score, ﬂavor proﬁle as. well as possible roast proﬁles and brew methods.

```{r}
# ggplot function to investigate the distribution of the variable Total.Cup.Points

ggplot(coffee_new_1, aes(x=Total.Cup.Points)) + geom_histogram(aes(y=..density..), binwidth=1, colour="black", fill="goldenrod2") +
  # Overlay with transparent (use the alpha parameter) blue density plot  
  geom_density(alpha=.2, fill="black") +   
  xlab("Coffee Cup Score") +
  ggtitle("Histogram and density plot of Cup Score")
```

The histogram output shows that Total.Cup.Points variable is normally distributed but slightly skewed to the right.
Moreover, the output also shows that most of the coffee beans have a score between 80 and 85.

Many research shows that Total.Cup.Points represents the coffee quality by gathering data from different variables: Aroma, Flavor, Aftertaste, Acidity, Body, Balance and Sweetness - hence, these variables need further investigation (Rachel, 2016; Porto, 2022 and Hyde, 2022).

# Green Analysis: Research (Daily Coffee, 2020) shows that a cofee green analysis investigates coffee grading, cupping score, flavor and roast profiles. Hence, it is crutial to analyse variables like Category.Defects and Quakers.

Having said that, it is important to understand how variables Category.One/Two.Defects and Quakers behave - as having Quakers leads to defects in coffee beans - Meaning, these three variables have a relationship between them.

```{r}
ggplot(coffee_new_1, aes(Category.One.Defects)) + geom_histogram(aes(y=..density..), binwidth=2, colour="black", fill="goldenrod2") + geom_density(alpha=.2, fill="blue")

ggplot(coffee_new_1, aes(Category.Two.Defects)) + geom_histogram(aes(y=..density..), binwidth=3, colour="black", fill="goldenrod2") + geom_density(alpha=.2, fill="darkblue")

ggplot(coffee_new_1, aes(Quakers)) + geom_histogram(aes(y=..density..), binwidth=0.7, colour="black", fill="goldenrod2") + ggtitle("Coffee Quakers") + geom_density(alpha=.2, fill="red")
```

The output shows two things:

1 - Category.One.Defects type of bean are rare, as are Quakers

2 - Category.Two.Defects bean are more common and the distribution appears to be approximately log-normal.

Moreover, the histogram representing the variable Quakers shows that this variable is not normal distributed. This happens because the collected coffee beans do not have many defects - as they were correctly collected. Hence, it is expected to see a distribution skewed to the left, when visually investigating the variable Quakers.

The output also shows that variables category defects have a higher density when the number of defects is very low.

#Cupping Scores Analysis Recent research shows that variables like Aroma and Flavor make up the cupping score - that makes it possible to investigate the quality of the coffee (Porto, 2022).

# Cupping Score analysis investigates the following variables: Acidity, Aroma, Flavor, Aftertaste, Body, Balance, Uniformity 

As outlined before in this project, the target variable is total Total.Cup.Points that corresponds to the total quality of the coffee beans.

Therefore, variables like Acidity, Aroma, Flavor, Aftertaste, Body, Balance, Uniformity should have a high correlated relationship with the target variable and because of that need further investigation.

Once again, as outlined above in the EDA section, these variables apparent to be normal distributed but it is necessary to plot them visually and confirm the summary statistics.


```{r}
# (Note: Displaying 4 histograms together at a time, is done using the par() function.)

#variable's distribution with histogram - histogram is used to display the distribution of continuous variables.

# the variables visual representation is divided into two parts; for a better understanding of the data.
# Part I with variables: Aroma, Flavor, Aftertaste and Acidity.
# Part II with variables: Body, Balance and Sweetness.

par(mfrow=c(1,4)) # Part I

hist(coffee_new_1$Aroma, main="Histogram of coffee Aroma",xlab="Coffee´s Aroma", ylab="")

hist(coffee_new_1$Flavor, main="Histogram of coffee Flavor",xlab="Coffee´s Flavor", ylab="")

hist(coffee_new_1$Aftertaste, main="Histogram of coffee Aftertaste",xlab="Coffee´s Aftertaste", ylab="")

hist(coffee_new_1$Acidity, main="Histogram of coffee Acidity",xlab="Coffee´s Acidity", ylab="")

par(mfrow=c(1,4)) # Part II

hist(coffee_new_1$Body, main="Histogram of coffee Body",xlab= "Coffee´s Body", ylab="")

hist(coffee_new_1$Balance, main="Histogram of coffee Balance",xlab="Coffee´s Balance", ylab="")

hist(coffee_new_1$Sweetness, main="Histogram of coffee Sweetness",xlab="Coffee´s Sweetness", ylab="")

hist(coffee_new_1$Clean.Cup, main="Histogram of coffee Clean.Cup",xlab="Coffee´s Clean.Cup", ylab="")
```

Part I output shows that the four variables are normally distributed and, Part II, shows that variables Body and Balance present a similar distribution. However, variables Sweetness and Clean.Cup do not behave the same way and needs further investigation, as they present a distribution skewed to the right.

Therefore, both variables Sweetness and Clean.Cup need further investigation and should probably not be included in the model.

# Sweetness

```{r}
ggplot(coffee_new_1, aes(x=Sweetness)) + geom_histogram(aes(y=..density..), 
                 binwidth=0.9, 
                 colour="black", 
                 fill="goldenrod2") +
  
  # Overlay with transparent (use the alpha parameter) blue density plot  
  geom_density(alpha=.2, fill="black") +   
  xlab("Coffee Sweetness") +
  ggtitle("Histogram and density plot of Coffee Sweetness")

count(coffee_new_1, 'Sweetness')
```

Sweetness are generally highly rated with little deviation from scores of 10, as shown in the table function output and this variable´s ggplot histogram.

Research shows that coffee beans are known for their sweetness - Colombia, Kenya, Guatemala, Panama, and Ethiopia are the countries producing the most sweet coffee beans (Coffee, 2022).

Therefore, even if the variable does not look normal distributed, it makes sense not to be.

# Clean.Cup

```{r}
ggplot(coffee_new_1, aes(x=Clean.Cup)) + geom_histogram(aes(y=..density..), 
                 binwidth=0.9, 
                 colour="blue", 
                 fill="goldenrod2") +
  
  # Overlay with transparent (use the alpha parameter) blue density plot  
  geom_density(alpha=.2, fill="blue") +   
  xlab("Coffee Clean.Cup") +
  ggtitle("Histogram and density plot of Coffee Clean.Cup")

count(coffee_new_1, 'Clean.Cup')
```

The histogram and count function show that the variable is not normal distributed. Hence, cannot be used in the machine learning method.

# 2 - analyse the continuous variables graphically against the Total.Cup.Points variable to understand if they affect that variable. If variables affect the Total.Cup.Points of coffee quality, then they should be taken into the Total.Cup.Points regression model.

# Country.of.Origin

# 1.

```{r}
ggplot(coffee_new_1, aes(Country.of.Origin, Total.Cup.Points)) + geom_boxplot() + coord_flip()
```

The output shows it impossible to find a pattern between the relationship of total cup points and country of origin.
Ethiopian, United States and Panama appears to be generally the coffee with highest scores.

# 2.

Moreover, the variable Country.of.Origin can also be used to investigate which countries produce more coffee - with the head, count and ggplot functions, as presented below. 

```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
require(graphics)
require("rgdal") 
require("maptools")
require("ggplot2")
require("plyr")

ggplot(coffee_new_1, aes(Country.of.Origin, Processing.Method)) + geom_count()

#head(coffee_new_1%>% 
 #      count(Country.of.Origin)%>% 
  #     arrange(desc(n)), 8)%>%

#ggplot(aes(x = n, y = reorder(coffee_new_1$Country.of.Origin, coffee_new_1$Processing.Method))) + geom_bar(stat = "identity", fill = "#0072B2") + labs(x = "Coffee Produced", y = "Country of Origin") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "pink"))
```

The output shows that Mexico, Guatemala and Colombia are the countries that produce more quantities of coffee.


# Country.of.Origin VS Processing.Method

Furthermore, it is necessary to investigate which processing method is used the most and the least - with the countries that produce more coffee, as outlined in the data cleaning stage of this project - this investigation will be presented below in the EDA part of the project.

```{r}
library(tidyverse)
coffee_new_1%>%
  filter(Country.of.Origin %in% c(coffee_new_1%>%
                                    count(Country.of.Origin)%>%
                                    filter(n >25)%>%
                                    pull(Country.of.Origin)))%>%
  filter(Processing.Method %in% c('Washed / Wet', 'Natural / Dry'))%>%
  count(Country.of.Origin, Processing.Method)%>%
  mutate(country = factor(Country.of.Origin, levels = c("Mexico", "Guatemala", "Colombia", "Brazil", 
                                                        "Taiwan", "Hawaii", "Honduras", "Costa Rica")))%>%
  ggplot(aes(x = country, y = n, fill = reorder(Processing.Method,-n))) + geom_col() + 
  labs(x = 'Number of Coffee', 
       y = 'Country', fill = 'Process Method') + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                                                       panel.background = element_blank(), axis.line = element_line(colour = "black")) + 
  scale_fill_manual(values=c("azure3","#0072B2"))
```

The output shows that Natural/Dry processing methods are mostly used in Brazil. The plot also shows that Washed/Wet processing methods are mostly used in Countries like Mexico, Guatemala and Colombia - as these countries produce more coffee, it is possible to conclude that Washed and Wet processing methods produce better results.


# Processing.Method vs Total.Cup.Points

```{r}
ggplot(coffee_new_1, aes(Processing.Method, Total.Cup.Points)) + geom_boxplot() + coord_flip()
```

The output shows that Washed/Wet processing method is the one with lowest coffee quality scores (Total Cup Points).
Furthermore, there are no visible trends within the data as all variables have similar means, meaning, similar coffee quality scores.


# Category.One.Defects, Category.Two.Defects and Quakers

```{r}
# The plot below shos too much information - it is not necessary to plot the data like this.
#plot(coffee_new_1, aes(Category.One.Defects, Total.Cup.Points))
par(mfrow=c(1,3)) # Part II
attach(coffee_new_1)
plot(Total.Cup.Points, Category.One.Defects, main="Defects type I vs Coffee Score", 
   xlab="Total.Cup.Points", ylab="Category.One.Defects", pch=19)

plot(Total.Cup.Points, Category.Two.Defects, main="Defects type II vs Coffee Score", 
   xlab="Total.Cup.Points", ylab="Category.Two.Defects", pch=19)

plot(Quakers, Quakers, Total.Cup.Points="Quakers vs Coffee Score", 
   xlab="Quakers", ylab="Total.Cup.Points", pch=19)
```

The output shows that for best coffee quality scores ( >80 Total.Cup.Points) happens when the number of defects and Quakers are low.
Therefore, variables like Category.One.Defects, Category.Two.Defects and Quakers affect the likelihood of increasing/decreasing the variable Total.Cup.Points - and should be included in the regression model.

# Moisture vs Total.Cup.Points

```{r}
attach(coffee_new_1)
plot(Total.Cup.Points, Moisture, main="Moisture Coffee Score", 
   xlab="Total.Cup.Points", ylab="Moisture", pch=19)
```

The output shows that a relationship between variables Total.Cup.Points and Moisture does not exist.


Subsequent research (Rachel, 2016), shows that Total.cup.points variable can be splited into 3 categories that represent the quality of the coffee beans.
These categories are presented below:

"65 – 80 = Commodity Coffee The type used to make supermarket coffee, blends and instant.
80+ = Specialty Coffee The flavours are more subtle, the cup more balanced. At Pact we only buy coffees of 84+, though most of them score 86+.
90+ = Presidential Award These prestigious coffees make up less than 1% of the specialty coffee market, they’re just that rare. And that good."

Mutate function is used below to create these categories and represent them visually. 

```{r}
coffee_new_1 <- coffee_new_1%>%
 mutate(grade = case_when(
   Total.Cup.Points >= 85 ~ 'Excellent',
   Total.Cup.Points >= 80 ~ 'Very Good',
   Total.Cup.Points < 80 ~ 'Not Special'
 ))

coffee_new_1$grade <- factor(coffee_new_1$grade, levels = c('Not Special', 'Very Good', 'Excellent'))

coffee_new_1%>%
  filter(Country.of.Origin %in% c(coffee_new_1%>%
                                    count(Country.of.Origin)%>%
                                    filter(n >25)%>%
                                    pull(Country.of.Origin)))%>%
  count(Country.of.Origin, grade)%>%
  mutate(country = factor(Country.of.Origin, levels = c("Mexico", "Guatemala", "Colombia", "Brazil", 
                                                        "Taiwan", "Honduras", "Costa Rica", "Tanzania",
                                                        "Uganda")))%>%
  ggplot(aes(x = country, y = n, fill = grade)) + geom_col() + 
  scale_fill_manual(values=c("azure3","#0072B2", 'darkorange')) +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"))
```



# REFERENCES:

1- https://www.boomtowncoffee.com/stories/what-is-cupping
2- https://bounbeans.com/blog-7-cup-score
3- https://www.pactcoffee.com/blog/speciality-coffee-quality-scores-explained
4- https://dailycoffeenews.com/2020/04/29/physical-analysis-of-green-coffee-what-to-measure-record-and-track/
5- https://dialupthecoffee.com/naturally-sweet-coffee/

